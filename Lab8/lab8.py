# -*- coding: utf-8 -*-
"""lab8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1N1-ZE5qGM1a8ZOZFSZthwMPRlyOrHKLj
"""

import numpy as np
from sympy.solvers import solve
import sympy as sp

"""gets the rotation matrix R and returns its inverse"""

def inverse_matrix(R):
    return np.linalg.inv(R)

R = np.array([[0, -1, 0], [0, 0, -1], [1, 0, 0]])
print("R is", R)
print("inverse matrix of R is", inverse_matrix(R))

"""gets a 3-vector ω and gives back the skew-symmetric matrix representation of it"""

def skew_symmetric(w):
  skew_matrix = np.zeros((3,3))
  skew_matrix[0,1] = -w[2]
  skew_matrix[0,2] = w[1]
  skew_matrix[1,0] = w[2]
  skew_matrix[1,2] = -w[0]
  skew_matrix[2,0] = -w[1]
  skew_matrix[2,1] = w[0]
  return skew_matrix

w = [1, -1, 1]
print("w is", w)
print("skew matrix of w is", skew_symmetric(w))

"""gets the angle
θ
 and the unit axis of rotation
ω
^
 and returns the rotation matrix representing the rotation about
ω
^
 by
θ
. This function should be able to handle the special cases of rotation operators about
x
^
,
y
^
, and
z
^
. Use Rodrigues' formula to write this function


"""

def RodrigueFormular(theta, ω):
  m = skew_symmetric(ω)
  if np.sin(theta) == 0:
    if (theta/np.pi)%2 == 0:
      R = np.eye(3)
    if (theta/np.pi)%2 != 1:
      R = np.eye(3) + 2*m@m
  else:
    R = np.eye(3)+np.sin(theta)*skew_symmetric(ω)+(1-np.cos(theta))*np.dot(skew_symmetric(ω), skew_symmetric(ω))
  return R

R = np.round(RodrigueFormular(np.pi, [0, 1/np.sqrt(2), -1/np.sqrt(2)]))
print(R)

"""gets the
3
×
3
 skew-symmetric matrix representation of
ω
^
 and returns the 3-verctor
ω
^
 (7 points).
"""

def vector_from_skew_symmetric(skew_matrix):
  return np.array([skew_matrix[2,1], skew_matrix[0,2], skew_matrix[1,0]])

print(vector_from_skew_symmetric(skew_symmetric([1, 1, 1])))

"""gest the 3-vector exponential coordinates for rotation
ω
^
θ
 and extracts the rotation axis
ω
^
 and the rotation amount
θ
"""

def rotation_axis_and_angle(w_exp):
  theta = np.linalg.norm(w_exp)
  w = w_exp/theta
  return theta, w
w_exp= np.pi*np.array([0, 1/np.sqrt(2), -1/np.sqrt(2)])
theta, w = rotation_axis_and_angle(w_exp)
print("theta is", theta)
print("w is", w)

"""gets a
3
×
3
 rotation matrix R and finds the axis
ω
^
, and angle
θ
 representation of it
"""

def inverse_RodrigueFormular(R):
  w1 = sp.symbols('w1')
  w2 = sp.symbols('w2')
  w3 = sp.symbols('w3')
  trace_value = (np.trace(R) - 1) / 2
  theta = np.arccos(np.clip(trace_value, -1, 1))
  theta_vector = [theta, 2 * np.pi - theta]
  for theta in theta_vector:
    if np.round(np.sin(theta)) != 0:
      w = 1/(2*np.sin(theta))*np.array([R-np.transpose(R)])
    else:
      if np.round((theta/np.pi))%2 == 0:
        w = np.array([0,0,0])
      else:
        w_skew = np.array([[0, -w3, w2], [w3, 0, -w1], [-w2, w1, 0]])@np.array([[0, -w3, w2], [w3, 0, -w1], [-w2, w1, 0]])
        w_sqrt = (R-np.eye(3))/2
        equations = []
        for i in range(3):
            for j in range(3):
                equations.append(sp.Eq(w_skew[i, j], w_sqrt[i, j]))

        sol = sp.solve(equations, (w1, w2, w3))
        w = sol

    return w, theta

R = np.array([[-1, 0, 0], [0, 0, -1], [0, -1, 0]])
w, theta = inverse_RodrigueFormular(R)
print("w is", w)
print("theta is", theta)

"""gets the rotation matrix
R
∈
S
O
(
3
)
 and a position vector
p
∈
R
3
 and returns the
4
×
4
 homogenous matrix T coressponding to them.
"""

def transformation_matrix(R, p):
  T = np.eye(4)
  T[:3, :3] = R
  T[:3, 3] = p
  T[3, 3] = 1
  return T

R = np.array([[0, -1, 0], [0, 0, -1], [1, 0, 0]])
p = np.array([3, 0, 0])
T = transformation_matrix(R, p)
print("T is", T)

"""gets the
4
×
4
 homogenous transformation matrix T and extract the
3
×
3
 rotation matrix and
3
×
1
 position vector from it.
"""

def rotation_matrix_and_position(T):
  R = T[:3, :3]
  p = T[:3, 3]
  return R, p

T = np.array([[0, -1, 0, 3], [0, 0, -1, 0], [1, 0, 0, 0], [0, 0, 0, 1]])
R, p = rotation_matrix_and_position(T)
print("R is", R)
print("p is", p)

"""gets the
4
×
4
 homogenous transformation matrix T and computes the inverse of it
"""

def inverse_transformation_matrix(T):
  R, p = rotation_matrix_and_position(T)
  R_inv = inverse_matrix(R)
  p_inv = -R_inv@p
  T_inv = transformation_matrix(R_inv, p_inv)
  return T_inv

T = np.array([[0, -1, 0, 3], [0, 0, -1, 0], [1, 0, 0, 0], [0, 0, 0, 1]])
T_inv = inverse_transformation_matrix(T)
print("T_inv is", T_inv)

"""gets a 3-vector and returns its homogenous coordinates"""

def homogenous_coordinates(v):
  return np.append(v, 1)


v = np.array([1, 2, 3])
print("homogenous coordinates of v is", homogenous_coordinates(v))

"""gets the
4
×
4
 homogenous transformation matrix T and computes its
6
×
6
 adjoint representation
[
A
d
T
]

"""

def adjoint_matrix(T):
  R, p = rotation_matrix_and_position(T)
  skew_p = skew_symmetric(p)
  A_d = np.eye(6)
  A_d[:3, :3] = R
  A_d[3:, :3] = skew_p@R
  A_d[:3, 3:] = np.zeros((3, 3))
  A_d[3:, 3:] = R
  return A_d

T = np.array([[0, -1, 0, 3], [0, 0, -1, 0], [1, 0, 0, 0], [0, 0, 0, 1]])
A_d = adjoint_matrix(T)
print("A_d is", A_d)

"""gets the 6-vector exponential coordinates of motion
S
q
 and extracts the normalized screw axis
S
 and the distance traveled along the screw q

"""

def exponential_coordinates2q_S(sixd_vector):
  norm = np.sqrt(np.square(sixd_vector[0])+np.square(sixd_vector[1])+np.square(sixd_vector[2]))
  if norm != 0:
    sixd_vector = sixd_vector/norm
    S = sixd_vector/norm
    q = norm
  else:
      S = np.array([0,0,0])
      q = 0
  return S, q

s_theta = [0, 1, 2, 3, 0, 0]
S, q = exponential_coordinates2q_S(s_theta)
print("S is", S)
print("q is", q)

"""gets the 6-vector screw axis and computes the matrix representation of it."""

def screw_axis_matrix(S):
  sw = S[0:3]
  skew_sw = skew_symmetric(sw)
  sv = S[3:6]
  M = np.zeros((4,4))
  M[:3, :3] = skew_sw
  M[0:3,3] = np.transpose(sv)
  return M

S = [0,1/np.sqrt(5),2/np.sqrt(5), 3/np.sqrt(5), 0, 0]
M = screw_axis_matrix(S)
print(M)

"""gets the screw axis
S
 and q and calculates the corresponding homogenous transformation matrix
T
∈
S
E
(
3
)
"""

def SQ2T(S, q):
  # q is in rad
  S = np.array(S)
  Sw = S[:3]

  Sv = S[3:]
  exp_sw = RodrigueFormular(q, Sw)
  Gtheta_sv = (np.eye(3) * q + (1 - np.cos(q)) * skew_symmetric(Sw) + (q - np.sin(q)) * skew_symmetric(Sw)@skew_symmetric(Sw)) @ Sv
  T = np.block([[exp_sw, Gtheta_sv[:, None]], [0, 0, 0, 1]])
  return T

T = SQ2T([0,1/np.sqrt(5),2/np.sqrt(5), 3/np.sqrt(5), 0, 0], 2.23)
print("T is", T)

"""gets the
4
×
4
 homogenous transformation matrix and computes the screw axis and q (6 points).


"""

def T2SQ(T: np.ndarray):
  T = np.array(T)
  R = T[:3, :3]
  p = T[:3, 3]
  trace_value = (np.trace(R) - 1) / 2
  theta = np.arccos(np.clip(trace_value, -1, 1))
  theta_vector = [theta, 2 * np.pi - theta]
  for q in theta_vector:
    # q = np.degrees(q)
    omega_matrix = 1/(2*np.sin(q))*(R-np.transpose(R))
    omega = vector_from_skew_symmetric(omega_matrix)
    Sw = omega
    Sv = (np.eye(3) * 1/q - (1/2) * skew_symmetric(Sw) + (1/q - 1/2*(1/np.tan(q/2))) * skew_symmetric(Sw)@skew_symmetric(Sw))@p
    S = np.concatenate((Sw, Sv))
    return S, q

T_sb = np.array([
    [0, -1, 0, 3],
    [0, 0, -1, 0],
    [1, 0, 0, 0],
    [0, 0, 0, 1]
])
S, q = T2SQ(T_sb)
print("S is", S)
print("q is", q)
